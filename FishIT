-- [[ MINI MINING HUB V4.8 - SMART IDLE ]]
-- Struktur: Save Pos -> Equip Pickaxe -> Mine (7s) -> Done -> Return -> Equip Rod -> Idle (Wait Spawn)

local Services = {
    Players = game:GetService("Players"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Workspace = game:GetService("Workspace"),
    RunService = game:GetService("RunService"),
    CoreGui = game:GetService("CoreGui"),
    TweenService = game:GetService("TweenService")
}

local Player = Services.Players.LocalPlayer

-- // 1. CONFIG REMOTE
local NetPath = Services.ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

local RemoteEquip = NetPath:WaitForChild("RE/EquipToolFromHotbar")
local RemoteUnequip = NetPath:WaitForChild("RE/UnequipToolFromHotbar")

local States = {
    AutoCrystal = false,
    AutoLava = false,
    IsMining = false
}

-- Fungsi Helper
local function GetChar() return Player.Character or Player.CharacterAdded:Wait() end
local function GetRoot() local c = Player.Character; return c and c:FindFirstChild("HumanoidRootPart") end
local function GetHum() local c = Player.Character; return c and c:FindFirstChild("Humanoid") end

-- // 2. FUNGSI EQUIP / UNEQUIP (AMAN)
local function ForceEquipSlot(slotNumber)
    local char = GetChar()
    local hum = GetHum()
    
    -- Cek dulu apakah perlu switch (agar tidak spam remote)
    local currentTool = char:FindFirstChildWhichIsA("Tool")
    -- Jika slot 2 (Pickaxe) dan kita sudah pegang sesuatu bernama "Pick", skip
    if slotNumber == 2 and currentTool and string.find(string.lower(currentTool.Name), "pick") then return end
    
    -- 1. Unequip Paksa
    pcall(function() RemoteUnequip:FireServer() end)
    if hum then hum:UnequipTools() end
    task.wait(0.5)

    -- 2. Equip Slot Target
    pcall(function() 
        local args = { slotNumber }
        RemoteEquip:FireServer(unpack(args)) 
    end)
    task.wait(0.5)
end

-- // 3. MOVEMENT & BYPASS
local NoclipConn = nil
local function SetBypass(bool)
    local hrp = GetRoot()
    local hum = GetHum()
    if not hrp or not hum then return end

    if bool then
        hum.PlatformStand = true
        if not hrp:FindFirstChild("MiningFly") then
            local bv = Instance.new("BodyVelocity")
            bv.Name = "MiningFly"
            bv.Parent = hrp
            bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bv.Velocity = Vector3.zero
        end
        if not NoclipConn then
            NoclipConn = Services.RunService.Stepped:Connect(function()
                if Player.Character then
                    for _, v in pairs(Player.Character:GetDescendants()) do
                        if v:IsA("BasePart") and v.CanCollide then v.CanCollide = false end
                    end
                end
            end)
        end
    else
        hum.PlatformStand = false
        if hrp:FindFirstChild("MiningFly") then hrp.MiningFly:Destroy() end
        if NoclipConn then NoclipConn:Disconnect(); NoclipConn = nil end
    end
end

local function SafeTween(targetCFrame)
    local hrp = GetRoot()
    if not hrp then return end
    
    local dist = (hrp.Position - targetCFrame.Position).Magnitude
    local speed = 60 -- Kecepatan
    local time = dist / speed
    if time < 0.1 then time = 0.1 end
    
    local ti = TweenInfo.new(time, Enum.EasingStyle.Linear)
    local tw = Services.TweenService:Create(hrp, ti, {CFrame = targetCFrame})
    tw:Play()
    tw.Completed:Wait()
    hrp.AssemblyLinearVelocity = Vector3.zero
end

-- // 4. UI SETUP
if Services.CoreGui:FindFirstChild("MiniMiningUI") then Services.CoreGui.MiniMiningUI:Destroy() end
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MiniMiningUI"
ScreenGui.Parent = Services.CoreGui

local MainFrame = Instance.new("Frame", ScreenGui)
MainFrame.Size = UDim2.new(0, 220, 0, 130)
MainFrame.Position = UDim2.new(0.5, -110, 0.2, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)

-- Dragging
local dragging, dragInput, dragStart, startPos
MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true; dragStart = input.Position; startPos = MainFrame.Position
    end
end)
MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)
MainFrame.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end end)

local Title = Instance.new("TextLabel", MainFrame)
Title.Text = "AUTO MINING V4.8"
Title.Size = UDim2.new(1,0,0,30)
Title.BackgroundTransparency = 1
Title.TextColor3 = Color3.new(1,1,1)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 14

local StatusLabel = Instance.new("TextLabel", MainFrame)
StatusLabel.Text = "Idle"
StatusLabel.Size = UDim2.new(1,0,0,20)
StatusLabel.Position = UDim2.new(0,0,1,-20)
StatusLabel.BackgroundTransparency = 1
StatusLabel.TextColor3 = Color3.fromRGB(150,150,150)

local function Notify(msg, color)
    StatusLabel.Text = msg
    StatusLabel.TextColor3 = color or Color3.new(1,1,1)
end

local function CreateBtn(txt, yPos, varName)
    local btn = Instance.new("TextButton", MainFrame)
    btn.Size = UDim2.new(0.9,0,0,30)
    btn.Position = UDim2.new(0.05,0,0,yPos)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,50)
    btn.Text = txt..": OFF"
    btn.TextColor3 = Color3.fromRGB(200,200,200)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
    
    btn.MouseButton1Click:Connect(function()
        States[varName] = not States[varName]
        if States[varName] then
            btn.Text = txt..": ON"
            btn.BackgroundColor3 = Color3.fromRGB(0,200,100)
            btn.TextColor3 = Color3.new(1,1,1)
        else
            btn.Text = txt..": OFF"
            btn.BackgroundColor3 = Color3.fromRGB(40,40,50)
            btn.TextColor3 = Color3.fromRGB(200,200,200)
            -- Reset jika dimatikan
            States.IsMining = false
            SetBypass(false)
            ForceEquipSlot(1) -- Balik ke Rod
        end
    end)
end

CreateBtn("Auto Crystal", 35, "AutoCrystal")
CreateBtn("Auto Lava", 70, "AutoLava")

-- // 5. LOGIKA UTAMA (LOOPING)
local function GetActiveNodes(folder)
    local list = {}
    if not folder then return list end
    for _, v in ipairs(folder:GetChildren()) do
        if v:FindFirstChild("ProximityPrompt", true) then table.insert(list, v) end
    end
    return list
end

local function ProcessMining(folderName, toggleState)
    while States[toggleState] do
        -- Ambil Folder
        local Islands = Services.Workspace:FindFirstChild("Islands")
        local TargetFolder = nil
        
        if folderName == "Crystal" then
            TargetFolder = Islands and Islands:FindFirstChild("Crystal Depths") and Islands["Crystal Depths"]:FindFirstChild("Crystals")
        elseif folderName == "Lava" then
            TargetFolder = Islands and Islands:FindFirstChild("Lava Basin") and Islands["Lava Basin"]:FindFirstChild("Crystals")
        end

        local activeNodes = GetActiveNodes(TargetFolder)

        if #activeNodes > 0 then
            -- [FASE 1: ADA CRYSTAL -> MULAI MINING]
            States.IsMining = true
            local hrp = GetRoot()
            
            -- 1. Save Posisi Awal
            local SavedPos = hrp.CFrame
            Notify("Mulai Mining...", Color3.fromRGB(0, 255, 0))
            task.wait(0.5)

            -- 2. Equip Pickaxe (Slot 2)
            ForceEquipSlot(2)
            SetBypass(true)

            -- 3. Loop Mining
            for i, node in ipairs(activeNodes) do
                if not States[toggleState] then break end
                
                local prompt = node:FindFirstChildWhichIsA("ProximityPrompt", true)
                if prompt and prompt.Enabled then
                    local targetCF = node:IsA("Model") and node:GetPivot() or node.CFrame
                    SafeTween(targetCF + Vector3.new(0, 3.5, 0))
                    
                    Notify("Mining " .. i .. "/" .. #activeNodes, Color3.fromRGB(255, 170, 0))
                    task.wait(0.5)
                    fireproximityprompt(prompt)
                    
                    -- DELAY 7 DETIK SETELAH EXTRACT
                    for cd = 7, 1, -1 do
                        if not States[toggleState] then break end
                        Notify("Extracting... " .. cd .. "s", Color3.fromRGB(100, 255, 100))
                        task.wait(1)
                    end
                end
            end

            -- [FASE 2: SELESAI SEMUA -> PULANG]
            Notify("Selesai! Pulang...", Color3.fromRGB(0, 255, 255))
            SafeTween(SavedPos)
            SetBypass(false)

            -- [FASE 3: EQUIP ROD (SLOT 1)]
            ForceEquipSlot(1)
            States.IsMining = false
        else
            -- [FASE IDLE: MENUNGGU CRYSTAL SPAWN]
            -- Pastikan Rod tetap dipegang saat menunggu
            local char = Player.Character
            if char and not char:FindFirstChildWhichIsA("Tool") then
                 ForceEquipSlot(1)
            end
            
            Notify("Idle: Menunggu Spawn...", Color3.fromRGB(255, 255, 0))
            task.wait(2) -- Cek lagi setiap 2 detik
        end
        
        task.wait(1)
    end
end

-- // RUN LOOPS
task.spawn(function()
    while true do
        if States.AutoCrystal then
            ProcessMining("Crystal", "AutoCrystal")
        end
        task.wait(1)
    end
end)

task.spawn(function()
    while true do
        if States.AutoLava then
            ProcessMining("Lava", "AutoLava")
        end
        task.wait(1)
    end
end)
